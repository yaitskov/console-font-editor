04.07.07 
1) переместил virtual bool new_size(const IOutline* subordinate, 
const Size& n_size) = 0; из IOutline в ILinkManager. Так как панели
не могут иметь подчиненных конутров - некому вызывать этот метод.
2) я не нашел ни одной причины создавать промежуточный класс IPanel,
поэтому буду полчать панели ввода и вывода прямо из IOutline.
05.07.07
1) если следовать пункту (4) в SCHEME тогда следует что панели ввода в 
библиотеке не имеют графического представления тогда зачем их нужно 
наследовать от IOutline потому что все его интерфейсные функции 
предназначены для объектов, имеющих графическое выражение. Действия:
исключить из потомков класс InPanel. Далее он не будет являться
самостоятельным.
09.07.07
	Упрощение в передаче управления. При подьеме по дереву объектов
маршутеризация производиться не будет. Первый этап - достижение корня дерева.
Второй этап без изменений. Исчез лишний аргумент.
	bool ITransmissionControl::Enter(bool& seq_dir, Directaddress& target,
			DirectAddress& source);
	Везъде вместо обычных указателей на классы будем использовать умные 
- cfe::tpointer<Type> (см. CLEAVE_POINTERS).
	Адаптеры - классы(функторы) специально предназначенные для 
распознования управляющих последовательностей(CommandDetector). События 
cfe::event<class functor, class arg> - вызов множества распознающих функцторов 
сразу(см EVENTS).
	Библиотека ncurses - хранит размеры окн, цвет. Нет наследования при
получении IOutline. Point и Size - теперь только для взаимодействия с объектами
являющимися IOutline.
12.07.07
	Писать проект не получается. Сразу мысли разбегаются при на писании
отладочного кода. Это такой код который будет информировать о месте и 
поверхностной причине ошибки. Для это нужно усовершенствовать набор макросов
(error.h) то не дублировать формальный код. Каждый из этих макросов в чем то
аналог asserta, но более продвинутый (проверка диапазона). Сохраняется главное
свойство assert'а - программа завершает свое выполение, информируя об ошибке
(fprintf(stderr )).
